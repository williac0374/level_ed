<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Level_Ed</title>
<script src= "codeMirror/codemirror.js"></script>
<link rel="stylesheet" href="codeMirror/codemirror.css">
<script src= "codeMirror/javascript.js"></script>
<link rel="stylesheet" href="codeMirror/base16-dark.css">
<script src= "codeMirror/matchbrackets.js"></script>
<script src= "help.js"></script>
<script src= "pre.js"></script>
<script src= "post.js"></script>
<script src= "TRYpost.js"></script>
<style>
body{
  margin: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 99vh;
  width: 100vw;
  background-color: black;
  overflow: hidden;
  
}
canvas {
  margin: 0;
  padding: 0;
  position: absolute;
  top: 0;
  left: 0;
  // border: 2px solid #000;
  background-color: rgb(88,88,88);
}
#editor{
  position: absolute;
  display: none;
  left:0%;
  top:0%;
  width: 100%;
  height: 100%;
  background-color: blue;
}
.CodeMirror {
  height: 100%; /* Ensure CodeMirror takes the full height of its container */
  width: 100%;  /* Ensure CodeMirror takes the full width of its container */
}
</style>
</head>

<body>
<input type="file" id="fileInput" accept=".json" style="display:none">
<input type="file" id="scriptInput" accept=".js" style="display:none">

<canvas id="canvas"></canvas>
<div id='editor'></div>
<script>
  errorPop=false
panelMiddle=0
duplicate={}
duplicating=false
//localStorage.removeItem("level_ed");window.close()
// Initialize CodeMirror
var editor = CodeMirror(document.getElementById("editor"), {
  mode: "javascript",
  theme: "base16-dark",
  lineNumbers: true,
  matchBrackets: true,
  lineWrapping: true,
  autoCloseBrackets: true,
  styleActiveLine: true
});
cMirrorCursor=null
editor.on("change",function(cm,change){
  mouse_right_down = false;
  cMirrorCursor=editor.getCursor()
  for(let i = objects.length-1; i>=0; i--){
    if(objects[i].sel==true){
    if(scriptMode==0){objects[i].startCode=editor.getValue()}
    if(scriptMode==1){objects[i].loopCode=editor.getValue()}
    if(scriptMode==2){objects[i].drawCode=editor.getValue()}
    if(scriptMode==3){objects[i].name=editor.getValue()}
    if(scriptMode==4){objects[i].tId=parseInt(editor.getValue())}
    if(scriptMode==5){project.gameCode=editor.getValue()}
      //project.gameCode
    }
  }
});
selectedRange = null;
selection = null
coding=false
editor.on('blur', () => {
  for(let i = objects.length-1; i>=0; i--){
    if(objects[i].sel==true){
    if(scriptMode==0){objects[i].startCode=editor.getValue()}
    if(scriptMode==1){objects[i].loopCode=editor.getValue()}
    if(scriptMode==2){objects[i].drawCode=editor.getValue()}
    if(scriptMode==3){objects[i].name=editor.getValue()}
    if(scriptMode==4){objects[i].tId=parseInt(editor.getValue())}
    if(scriptMode==5){project.gameCode=editor.getValue()}
    }
  }
  coding=false;
  mouse_right_down = false;
  selection = editor.getSelection();
  if (selection) {
    selectedRange = editor.listSelections()[0];
  }
});

editor.on('focus', () => {
  coding=true;
});

function resizeCanvas() {
  var WIDTH = window.visualViewport ? window.visualViewport.width : window.innerWidth;
  var HEIGHT = window.visualViewport ? window.visualViewport.height : window.innerHeight;
  canvas.width=WIDTH;
  canvas.height=HEIGHT;
  document.getElementById("editor").style.left=(tilesRect.x+4)+'px';
  document.getElementById("editor").style.top=(tilesRect.y+4)+'px';
  document.getElementById("editor").style.width=(tilesRect.w-8)+'px';
  document.getElementById("editor").style.height=(tilesRect.h-8)+'px';
  document.getElementsByClassName("CodeMirror")[0].style.fontSize =   project.codeSize+"px";
  editor.refresh();
  panelMiddle = canvas.width/2
}

// Call resizeCanvas immediately on load and bind to resize event
setTimeout(function(){
  resizeCanvas();
  setTimeout(function(){
    makeButton(tilesRect.x+4,4,'NAME','scriptMode=3;show_code();mouse_down=false');
    makeButton(tilesRect.x+64,4,'tId','scriptMode=4;show_code();mouse_down=false');
    makeButton(tilesRect.x+124,4,'START','scriptMode=0;show_code();mouse_down=false');
    makeButton(tilesRect.x+184,4,'LOOP','scriptMode=1;show_code();mouse_down=false');
    makeButton(tilesRect.x+244,4,'DRAW','scriptMode=2;show_code();mouse_down=false');
    makeButton(tilesRect.x+304,4,'HELP','helpBox();mouse_down=false');
    makeButton(tilesRect.x+364,4,'LOAD','loadScript();mouse_down=false');
    makeButton(tilesRect.x+424,4,'SAVE','exportScript();mouse_down=false');
    makeButton(tilesRect.x+484,4,'Gcode','scriptMode=5;show_code();mouse_down=false');
    setTimeout(function(){
      var tick=1
      buttons.forEach(button => {
        if(button.label!='NAME' &&button.label!='tId' && button.label!='START' && button.label!='LOOP' && button.label!='DRAW' && button.label!='HELP'&& button.label!='LOAD'&& button.label!='SAVE'&& button.label!='Gcode'){
          button.tsize=text_fit(button.label,button.w-20)
        }else{
          button.tsize=text_fit(button.label,button.w-70)
        }
      });
    },100);
  },100);
},100);
setTimeout(function(){
  document.getElementById("editor").style.left=(tilesRect.x+4)+'px';
  document.getElementById("editor").style.top=(tilesRect.y+4)+'px';
  document.getElementById("editor").style.width=(tilesRect.w-8)+'px';
  document.getElementById("editor").style.height=(tilesRect.h-8)+'px';
  document.getElementsByClassName("CodeMirror")[0].style.fontSize =   project.codeSize+"px";
  editor.refresh();
  tilesRect.tilesX=canvas.width/2+4;
  tilesRect.tilesY=menuRect.h+4;
},500);
//buttons
window.addEventListener('resize', resizeCanvas);
function reset(){
project = {title:'none',tileSet:null,objects:[],gameCode:"function hello(){'hello world!!!'}",codeSize:12,tColumns:10,view:{x:0,y:0,w:120,h:120}};
  mode = 2;
  tiles = [];
  tiles2 = [];
  objects = [];
  tiles3 = [];
  snapped=true;
  obID=0;
  after_start=false
  object_code=''
  buttons = [];
  b_width = 5;
duplicate = {}
  duplicating=false
  cur_value = null;
  codeCursor=null
  line = ''
  scriptMode = 3;
  title='none'
  document.title = title
}
reset();
menuRect = {
  x:0,
  y:0,
  w:canvas.width,
  h:50,
  mode:0,
  draw:function(){
    draw_rect_ol(this.x,this.y,this.w,this.h,4,[88,88,88],[255,255,255])
  },
  loop:function(){
    this.x = 0;
    this.y = 0;
    this.w = canvas.width;
    this.h = 50;
    if(this.mode==0){
      for(let i = 0; i < 13; i++){
        buttons[i].loop();
        buttons[i].draw();
      }
    }
    if(this.mode==1){
      for(let i = 13; i < 22; i++){
        buttons[i].loop();
        buttons[i].draw();
        draw_set_color(255,255,255)
        let wideZone = text_fit('mouse wheel here to adjust code size',canvas.width/2-100)
        draw_text(this.x+4,this.y+12,'mouse wheel here to adjust code size',wideZone , 100)
      }
    }
    // hi-lites correct mode button
    if(menuRect.mode==0){
      draw_set_color(0,255,0);
      draw_set_linewidth(8);
      if(mode==0){
        buttons[6].hilite=true;
        buttons[7].hilite=false;
        buttons[8].hilite=false;
        buttons[9].hilite=false;
      }
      if(mode==1){
        buttons[6].hilite=false;
        buttons[7].hilite=true;
        buttons[8].hilite=false;
        buttons[9].hilite=false;
      }
      if(mode==2){
        buttons[6].hilite=false;
        buttons[7].hilite=false;
        buttons[8].hilite=true;
        buttons[9].hilite=false;
      }
      if(mode==3){
        buttons[6].hilite=false;
        buttons[7].hilite=false;
        buttons[8].hilite=false;
        buttons[9].hilite=true;
      }
    }
    if(menuRect.mode==1){
      if(inside(mouse_x, mouse_y, this.x, this.y, this.w, this.h, 0, 0, 0)){
        project.codeSize += wheelDir
      if(project.codeSize<12){project.codeSize=12}
        document.getElementsByClassName("CodeMirror")[0].style.fontSize =   project.codeSize+"px";
        wheelDir=0;
        editor.refresh();
      }
      draw_set_color(128,0,128);
      draw_set_linewidth(8);
      
      if(scriptMode==5){
        buttons[13].hilite=false;
        buttons[14].hilite=false;
        buttons[15].hilite=false;
        buttons[16].hilite=false;
        buttons[17].hilite=false;
        buttons[21].hilite=true;
      }
      if(scriptMode==4){
        buttons[13].hilite=false;
        buttons[14].hilite=true;
        buttons[15].hilite=false;
        buttons[16].hilite=false;
        buttons[17].hilite=false;
        buttons[21].hilite=false;
      }
      if(scriptMode==3){
        buttons[13].hilite=true;
        buttons[14].hilite=false;
        buttons[15].hilite=false;
        buttons[16].hilite=false;
        buttons[17].hilite=false;
        buttons[21].hilite=false;
      }
      if(scriptMode==0){
        buttons[13].hilite=false;
        buttons[14].hilite=false;
        buttons[15].hilite=true;
        buttons[16].hilite=false;
        buttons[17].hilite=false;
        buttons[21].hilite=false;
      }
      if(scriptMode==1){
        buttons[13].hilite=false;
        buttons[14].hilite=false;
        buttons[15].hilite=false;
        buttons[16].hilite=true;
        buttons[17].hilite=false;
        buttons[21].hilite=false;
      }
      if(scriptMode==2){
        buttons[13].hilite=false;
        buttons[14].hilite=false;
        buttons[15].hilite=false;
        buttons[16].hilite=false;
        buttons[17].hilite=true;
        buttons[21].hilite=false;
      }
    }
  }
}
t1HL=true;
t2HL=true;
oHL=true;
t3HL=true;
hl = 0
setInterval(function(){if(hl>1000){hl=0}hl++},100)
mapRect = {
  x:0,
  y:menuRect.h,
  w:canvas.width/2,
  h:canvas.height-20,
  mapX:0,
  mapY:menuRect.h,
  offX:0,
  offY:0,
  mapW:10,
  mapH:10,
  mapG:16,
  draw:function(){
    
    if(tilesRect.sprite!=null){
      for (let y = 0; y < tiles.length; y++) {
        for (let x = 0; x < tiles[y].length; x++) {
          if(tiles[y][x]!=-1){
            let tId = tiles[y][x];
            let sx = tId%tilesRect.columns*tilesRect.gridSize;
            let sy = floor(tId/tilesRect.columns)*tilesRect.gridSize;
            draw_image(tilesRect.sprite,this.mapX+4+(x*this.mapG),this.mapY+4+(y*this.mapG),this.mapG,this.mapG,0,0,0,sx,sy,tilesRect.gridSize,tilesRect.gridSize)
            if(t1HL==true){
              draw_set_color(255,255,255)
              draw_set_linewidth(6)
              ctx.lineDashOffset = -hl;
              draw_set_linedash([6,4])
              draw_rectangle(this.mapX+4+(x*this.mapG),this.mapY+4+(y*this.mapG),this.mapG,this.mapG,true,0,0,0)
              draw_set_linedash([])
              ctx.lineDashOffset = 0
            }
          }
        }
      }
      for (let y = 0; y < tiles2.length; y++) {
        for (let x = 0; x < tiles2[y].length; x++) {
          if(tiles2[y][x]!=-1){
            let tId = tiles2[y][x];
            let sx = tId%tilesRect.columns*tilesRect.gridSize;
            let sy = floor(tId/tilesRect.columns)*tilesRect.gridSize;
            draw_image(tilesRect.sprite,this.mapX+4+(x*this.mapG),this.mapY+4+(y*this.mapG),this.mapG,this.mapG,0,0,0,sx,sy,tilesRect.gridSize,tilesRect.gridSize)
            if(t2HL==true){
              draw_set_color(255,255,255)
              draw_set_linewidth(6)
              ctx.lineDashOffset = -hl;
              draw_set_linedash([6,4])
              draw_rectangle(this.mapX+4+(x*this.mapG),this.mapY+4+(y*this.mapG),this.mapG,this.mapG,true,0,0,0)
              draw_set_linedash([])
              ctx.lineDashOffset = 0
            }
          }
        }
      }
      for(let i = objects.length-1; i>=0; i--){
        if(objects[i].tId!=-1){
          let tId = objects[i].tId;
          let x = objects[i].x;
          let y = objects[i].y;
          let cx = objects[i].mapX;
          let cy = objects[i].mapY;
          let sx = tId%tilesRect.columns*tilesRect.gridSize;
          let sy = floor(tId/tilesRect.columns)*tilesRect.gridSize;
          let ox = (this.mapG*objects[i].w)/2;
          let oy = (this.mapG*objects[i].h)/2;
          draw_image(tilesRect.sprite,this.mapX+4+(cx*this.mapG),this.mapY+4+(cy*this.mapG),this.mapG*objects[i].w,this.mapG*objects[i].h,objects[i].rot,ox,oy,sx,sy,tilesRect.gridSize,tilesRect.gridSize)
          if(objects[i].sel==true){
                   draw_set_color(255,255,255)
            draw_set_linewidth(6)
            ctx.lineDashOffset = -hl;
            draw_set_linedash([6,4])
            draw_rectangle(this.mapX+4+(cx*this.mapG),this.mapY+4+(cy*this.mapG),this.mapG*objects[i].w,this.mapG*objects[i].h,true,objects[i].rot,ox,oy)
            draw_set_linedash([])
            ctx.lineDashOffset = 0 }
          if(oHL==true){
            draw_set_color(255,255,255)
            draw_set_linewidth(6)
            ctx.lineDashOffset = -hl;
            draw_set_linedash([6,4])
            draw_rectangle(this.mapX+4+(cx*this.mapG),this.mapY+4+(cy*this.mapG),this.mapG*objects[i].w,this.mapG*objects[i].h,true,objects[i].rot,ox,oy)
            draw_set_linedash([])
            ctx.lineDashOffset = 0
          }
        }
        
      }
      for (let y = 0; y < tiles3.length; y++) {
        for (let x = 0; x < tiles3[y].length; x++) {
          if(tiles3[y][x]!=-1){
            let tId = tiles3[y][x];
            let sx = tId%tilesRect.columns*tilesRect.gridSize;
            let sy = floor(tId/tilesRect.columns)*tilesRect.gridSize;
            draw_image(tilesRect.sprite,this.mapX+4+(x*this.mapG),this.mapY+4+(y*this.mapG),this.mapG,this.mapG,0,0,0,sx,sy,tilesRect.gridSize,tilesRect.gridSize)
            if(t3HL==true){
              draw_set_color(255,255,255)
              draw_set_linewidth(6)
              ctx.lineDashOffset = -hl;
              draw_set_linedash([6,4])
              draw_rectangle(this.mapX+4+(x*this.mapG),this.mapY+4+(y*this.mapG),this.mapG,this.mapG,true,0,0,0)
              draw_set_linedash([])
              ctx.lineDashOffset = 0
            }
          }
        }
      }
    }
    
    // viewport border
    draw_set_color(255,255,0)
    draw_set_linewidth(4)
    draw_set_linedash([2,5])//this.mapX+4,this.mapY+4
    var mapScale = (this.mapG/tilesRect.gridSize)
    
    draw_rectangle( this.mapX+4+(project.view.x*mapScale),this.mapY+4+(project.view.y*mapScale), project.view.w*mapScale,project.view.h*mapScale,true)
    draw_set_linedash([])
    // mapRect border
    draw_set_color(255,255,255)
    draw_set_linewidth(8)
    draw_set_linedash([])
    draw_rectangle( this.x, this.y, this.w, this.h,true)
    if(t1HL==false&&t2HL==false&&oHL==false&&t3HL==false){
      drawG(this.mapX+4,this.mapY+4,this.mapG,this.mapG,this.mapW*this.mapG,this.mapH*this.mapG)
    }
  },
  init:function(){
    objects = [];
    project.objects = objects;
    tiles = [];
    tiles2 = [];
    tiles3 = [];
    for (let i = 0; i < this.mapH; i++) {
      var row = [];
      for (let j = 0; j < this.mapW; j++) {
        row.push(-1);
      }
      tiles.push(row);
    }
    project.tiles=tiles;
    for (let i = 0; i < this.mapH; i++) {
      var row = [];
      for (let j = 0; j < this.mapW; j++) {
        row.push(-1);
      }
      tiles2.push(row);
    }
    project.tiles2=tiles2;
    for (let i = 0; i < this.mapH; i++) {
      var row = [];
      for (let j = 0; j < this.mapW; j++) {
        row.push(-1);
      }
      tiles3.push(row);
    }
    project.tiles3=tiles3;
    project.mapW = this.mapW;
    project.mapH = this.mapH;
  },
  loop:function(){
    this.x = 0;
    this.y = menuRect.h;
    this.w = canvas.width/2;
    this.h = canvas.height-menuRect.h;
    
    if(inside(mouse_x, mouse_y, this.x, this.y, this.w, this.h, 0, 0, 0)){
      var w = 0;
      var h = 0;
      var r = 0;
      var v = 0;
      var s = 0;
      var shft = 0;
      var d = 0;
      var p = 0;
      var e = 0;
      var ikey = 0;
    if(keyboard_check(vk_w)){w=1};
    if(keyboard_check(vk_h)){h=1};
    if(keyboard_check(vk_r)){r=1};
    if(keyboard_check(vk_v)){v=1};
    if(keyboard_check(vk_s)){s=1};
    if(keyboard_check(vk_shift)){shft=1};
    if(keyboard_check(vk_d)){d=1};
    if(keyboard_check(vk_e)){e=1};
    if(keyboard_check(vk_p)){p=1};
    if(keyboard_check(vk_i)){ikey=1};
      if(keyboard_check_pressed(vk_space)){
        this.offX = mouse_x - this.mapX
        this.offY = mouse_y - this.mapY
      }
      if(keyboard_check(vk_space)){
        this.mapX = mouse_x - this.offX
        this.mapY = mouse_y - this.offY
        if(keyboard_check_pressed(vk_backspace)){
          this.mapX = 0;
          this.mapY = 0;
          this.offX = mouse_x - this.mapX
          this.offY = mouse_y - this.mapY
        }
      }
      
      
      
      if(w+h+r+v+shft+d+p+e+ikey>0){
        if(v==0){
          for(let i = objects.length-1; i>=0; i--){
            if(objects[i].sel==true && document.getElementById("customTextBox")==null){
            if(w>0){objects[i].w+=wheelDir*0.1}  //adjust selected objects width with mouse wheel
            if(h>0){objects[i].h+=wheelDir*0.1}  // adjust selected objects height with mouse wheel
            if(r>0){objects[i].rot+=wheelDir*5}  //adjust selected objects rotation with mouse wheel
              //
              if(shft+e==2){ // exports currently selected object to json file
                shft=0;
                e=0;
                key_down[vk_e]=false
                objects[i].sel=false
                exportObject(objects[i])
                
                
              }
              if(shft+ikey==2){ // imports object into currently selected object from json file
                objects[i].sel=false
                shft=0;
                ikey=0;
                key_down[vk_i]=false
                hostOb = i
                loadOb();
                
              }
              if(shft+d==2){ // copies currently selected object to be placed with cursor
                duplicate = {
                  name:'no_name',
                  tId:objects[i].tId,
                  x:objects[i].x,
                  y:objects[i].y,
                  depth:objects[i].depth,
                  mapX:objects[i].mapX,
                  mapY:objects[i].mapY,
                  w:1,
                  h:1,
                  rot:0,
                  ox:0,
                  oy:0,
                  startCode:objects[i].startCode,
                  loopCode:objects[i].loopCode,
                  drawCode:objects[i].drawCode,
                  sel:false
                }
                duplicating=true
                selected.tId = duplicate.tId
                selected.cellX = selected.tId%tilesRect.columns;
                selected.cellY = floor(selected.tId/tilesRect.columns);
                cur_value = tilesRect.sprite
                
                duplicate.name = makeName();
                console.log(duplicate)
                objects[i].sel=false
              }
              
            }
          }
          project.objects = objects
          localStorage.setItem("level_ed", JSON.stringify(project))
        }
      }else{
        if(document.getElementById("customTextBox")==null){
          if(mouse_x<parseFloat(document.getElementById("editor").style.left)){
            this.mapG += wheelDir*1.5;
          }
        }
      }
      wheelDir=0;
      var obj_move = false
      for(let i = objects.length-1; i>=0; i--){
        if(objects[i].sel==true){
          obj_move=true;
          let mod = 0.1
          
        if(keyboard_check_pressed(vk_up)){objects[i].mapY-= mod;objects[i].y-=mod*this.mapG}
        if(keyboard_check_pressed(vk_down)){objects[i].mapY += mod;objects[i].y+=mod*this.mapG}
        if(keyboard_check_pressed(vk_left)){objects[i].mapX -= mod;objects[i].x-=mod*this.mapG}
        if(keyboard_check_pressed(vk_right)){objects[i].mapX +=mod;objects[i].x+=mod*this.mapG}
        }
      }
      project.objects = objects
      localStorage.setItem("level_ed", JSON.stringify(project))
      if(obj_move==false){
      if(keyboard_check(vk_up)){this.mapY -= this.mapG/10}
      if(keyboard_check(vk_down)){this.mapY += this.mapG/10}
      if(keyboard_check(vk_left)){this.mapX -= this.mapG/10}
      if(keyboard_check(vk_right)){this.mapX += this.mapG/10}
      }
      let gs = this.mapG
      let mx = mouse_x;
      let my = mouse_y;
      if(mode<2||snapped==true){
        mx = (floor((mouse_x-this.mapX)/gs)*gs)+this.mapX+4
        my = (floor((mouse_y-this.mapY)/gs)*gs)+this.mapY+4
      }
      cursor(mx,my,gs,gs,cur_value)
      
      mapCellX = 0;
      mapCellY = 0;
    if((mx-this.mapX-4)>0){mapCellX = (mx-this.mapX-4)/this.mapG}
    if((my-this.mapY-4)>0){mapCellY = (my-this.mapY-4)/this.mapG}
      if(mouse_right_down){  // checks if right mouse button is being pressed
        //clears selected tile for assignment
        selected.tId=-1;
      duplicate = {};
        duplicating = false;
        cur_value=null;
        if(mx>this.mapX && mx < this.mapX+this.mapW*this.mapG){
          if(my>this.mapY && my < this.mapY+this.mapH*this.mapG){
            if(mode==0){
              tiles[mapCellY][mapCellX]=-1;
              project.tiles[mapCellY][mapCellX]=-1;
            }
            if(mode==1){
              tiles2[mapCellY][mapCellX]=-1;
              project.tiles2[mapCellY][mapCellX]=-1;
            }
            if(mode==3){
              tiles3[mapCellY][mapCellX]=-1;
              project.tiles3[mapCellY][mapCellX]=-1;
            }
            if(mode==2){
              for(let i = objects.length-1; i>=0; i--){
                let cx = objects[i].mapX;
                let cy = objects[i].mapY;
                let obx = this.mapX+4+(cx*this.mapG);
                let oby = this.mapY+4+(cy*this.mapG);
                let scaledW = this.mapG*objects[i].w;
                let scaledH = this.mapG*objects[i].h;
                let ox = (this.mapG*objects[i].w)/2;
                let oy = (this.mapG*objects[i].h)/2;
                if(inside(mouse_x, mouse_y, obx-(scaledW/2),oby-(scaledH/2), scaledW, scaledH,true,objects[i].rot,ox,oy)){
                  objects.splice(i,1);
                }
              }
            }
          }
        }
      }
      if(mouse_check()){
        if(mx>this.mapX && mx < this.mapX+this.mapW*this.mapG){
          if(my>this.mapY && my < this.mapY+this.mapH*this.mapG){
            
            if(v>0){
              if(s==0){
                project.view.x = mapCellX*tilesRect.gridSize;
                project.view.y = mapCellY*tilesRect.gridSize;
              }
              if(s>0){
                if(mx > project.view.x){
                  project.view.w = ((mapCellX+1)*tilesRect.gridSize) -  project.view.x
                }
              }
              if(s>0){
                if(my > project.view.y){
                  project.view.h = ((mapCellY+1)*tilesRect.gridSize) -  project.view.y
                }
              }
            }
            
            if(cur_value!=null){ // has a tile selected for assignment
              
              if(mode==0){
                tiles[mapCellY][mapCellX]=selected.tId;
                project.tiles[mapCellY][mapCellX]=selected.tId;
              }
              if(mode==1){
                tiles2[mapCellY][mapCellX]=selected.tId;
                project.tiles2[mapCellY][mapCellX]=selected.tId;
              }
              if(mode==3){
                tiles3[mapCellY][mapCellX]=selected.tId;
                project.tiles3[mapCellY][mapCellX]=selected.tId;
              }
              if(mode==2){
                if(duplicating==false){
                  let temp = {
                    name:makeName(),
                    tId:selected.tId,
                    depth:0,
                    x:mx,
                    y:my,
                    mapX:mapCellX+0.5,
                    mapY:mapCellY+0.5,
                    w:1,
                    h:1,
                    rot:0,
                    ox:0,
                    oy:0,
                    startCode:"",
                    loopCode:"",
                    drawCode:"",
                    sel:false
                  }
                  objects.push(temp);
                  project.objects = objects;
                }else{
                  let temp = {
                    name:makeName(),
                    tId:duplicate.tId,
                    x:mx,
                    y:my,
                    depth:duplicate.depth,
                    mapX:mapCellX+0.5,
                    mapY:mapCellY+0.5,
                    w:1,
                    h:1,
                    rot:0,
                    ox:0,
                    oy:0,
                    startCode:duplicate.startCode,
                    loopCode:duplicate.loopCode,
                    drawCode:duplicate.drawCode,
                    sel:false
                  }
                  objects.push(temp);
                //duplicate={};
                  localStorage.setItem("level_ed", JSON.stringify(project))
                  mouse_down=false
                }
                mouse_down=false
              }
              localStorage.setItem("level_ed", JSON.stringify(project))
              
            }else{
              if(mode==2){
                var noneSelected=true
                for(let i = objects.length-1; i>=0; i--){
                  let cx = objects[i].mapX;
                  let cy = objects[i].mapY;
                  let obx = this.mapX+4+(cx*this.mapG);
                  let oby = this.mapY+4+(cy*this.mapG);
                  let scaledW = this.mapG*objects[i].w;
                  let scaledH = this.mapG*objects[i].h;
                  let ox = (this.mapG*objects[i].w)/2;
                  let oy = (this.mapG*objects[i].h)/2;
                  draw_set_color(255,255,255)
                  draw_set_linewidth(2)
                  draw_set_linedash([8,2])
                  draw_rectangle(obx,oby,scaledW,scaledH,true,objects[i].rot,ox,oy)
                  draw_set_linedash([])
                  if(inside(mouse_x, mouse_y, obx-(scaledW/2),oby-(scaledH/2), scaledW, scaledH,true,objects[i].rot,ox,oy)){//object clicked
                  for(let o = 0; o < objects.length;o++){objects[o].sel=false}///????hopefully
                    objects[i].sel=true;
                  if(scriptMode==0){object_code=JSON.stringify(objects[i].startCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
                  if(scriptMode==1){object_code=JSON.stringify(objects[i].loopCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
                  if(scriptMode==2){object_code=JSON.stringify(objects[i].drawCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
                  if(scriptMode==3){object_code=JSON.stringify(objects[i].name).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
                  if(scriptMode==4){object_code=JSON.stringify(objects[i].tId).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
                  if(scriptMode==5){object_code=JSON.stringify(project.gameCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
                    //SHOWS EDITOR AND SETS INITIAl VALUE
                    document.getElementById("editor").style.display='block'
                    editor.setValue(object_code);
                    noneSelected = false;
                    ;mouse_down=false;
                  }else{
                    objects[i].sel=false
                    ;mouse_down=false;
                  }
                }
                if(noneSelected==true){
                  if(mouse_x<parseFloat(document.getElementById("editor").style.left)){
                    document.getElementById("editor").style.display='none'
                    menuRect.mode=0;
                  }
                }else{
                  menuRect.mode=1;
                }
              }else{
                if(mode==0){
               //   tiles[mapCellY][mapCellX]=selected.tId;
                //  project.tiles[mapCellY][mapCellX]=selected.tId;
                }
                if(mode==1){
                //  tiles2[mapCellY][mapCellX]=selected.tId;
                //  project.tiles2[mapCellY][mapCellX]=selected.tId;
                }
                if(mode==3){
                //  tiles3[mapCellY][mapCellX]=selected.tId;
                //  project.tiles3[mapCellY][mapCellX]=selected.tId;
                }
                
              }
            }
          }
        }
      }
    }
  }
}
mapRect.init();
tilesRect = {
  x:canvas.width/2,
  y:menuRect.h,
  w:canvas.width/2,
  h:canvas.height-menuRect.h,
  tilesX:canvas.width/2+4,
  tilesY:menuRect.h+4,
  gridSize:32,
  sorX:0,
  sorY:0,
  columns:0,
  sprite:null,
  scale:1,
  draw:function(){
    
    draw_rect_ol(this.x,this.y,this.w,this.h,4,[88,88,88],[255,255,255])
    if(menuRect.mode==0){
      if(this.sprite!=null){
        
        // draw_image(this.sprite,this.tilesX,this.tilesY,this.sprite.width*this.scale,this.sprite.height*this.scale)
        draw_image(this.sprite,this.tilesX,this.tilesY,this.sprite.width*this.scale,this.sprite.height*this.scale,0,0,0,this.sorX,this.sorY,this.sprite.width,this.sprite.height)
        drawG(this.tilesX,this.tilesY,this.gridSize*this.scale,this.gridSize*this.scale,this.sprite.width*this.scale,this.sprite.height*this.scale);
        
      }
    }
    
  },
  loop:function(){
    
    if(menuRect.mode==0){
      this.x = panelMiddle;
      this.y = menuRect.h;
      this.w = canvas.width-panelMiddle;
      this.h = canvas.height-menuRect.h;
      if(this.sprite!=null){
        if(inside(mouse_x, mouse_y, this.x, this.y, this.w, this.h, 0, 0, 0)){
          if(keyboard_check_pressed(vk_space)){
            this.offX = mouse_x - this.sorX;
            this.offY = mouse_y - this.sorY;
          }
          if(keyboard_check(vk_space)){
            this.sorX = snap(mouse_x - this.offX,this.gridSize)
            this.sorY = snap(mouse_y - this.offY,this.gridSize)
            if(keyboard_check_pressed(vk_backspace)){
              this.sorX = 0;
              this.sorY = 0;
              this.offX = mouse_x - this.sorX;
              this.offY = mouse_y - this.sorY;
            }
          }
        if(keyboard_check_pressed(vk_up)){this.sorY -= this.gridSize}
        if(keyboard_check_pressed(vk_down)){this.sorY += this.gridSize}
        if(keyboard_check_pressed(vk_left)){this.sorX -= this.gridSize}
        if(keyboard_check_pressed(vk_right)){this.sorX += this.gridSize}
          if(wheelDir<1){
          if(this.scale>0.1){this.scale += wheelDir*0.05;}
          }else{
            this.scale += wheelDir*0.05;
          }
          console.log(this.scale)
          wheelDir=0;
          let gs = this.gridSize*this.scale
          let mx = (floor((mouse_x-this.tilesX)/gs)*gs)+this.tilesX
        if(mx>(this.sprite.width*this.scale+this.tilesX)-gs){mx = (this.sprite.width*this.scale+this.tilesX)-gs}
          let my = (floor((mouse_y-this.tilesY)/gs)*gs)+this.tilesY
        if(my>(this.sprite.height*this.scale+this.tilesY)-gs){my = (this.sprite.height*this.scale+this.tilesY)-gs}
          
          let sx =(this.sprite.width*this.scale)
          cursor(mx,my,gs,gs,null)
          if(selected.tId!=null){
            let modX = this.sorX/this.gridSize
            let modY = this.sorY/this.gridSize
            selected.x=((selected.cellX-modX)*gs)+this.tilesX;
            selected.y=((selected.cellY-modY)*gs)+this.tilesY;
            selected.w=gs;
            selected.h=gs;
          }
          ////////////////////////////////////////////////////////
          // displays tId of tilemap hovered over
          let tX=round((mx - (this.x+4))/((this.sprite.width*this.scale)/((this.sprite.width*this.scale)/(this.gridSize*this.scale))))+(this.sorX/this.gridSize)
          let tY=round((my - (this.y+4))/((this.sprite.height*this.scale)/((this.sprite.height*this.scale)/(this.gridSize*this.scale))))+(this.sorY/this.gridSize)
          document.title = 'tId: '+floor((tY*this.columns)+tX)
          ////////////////////////////////////////////
          if(mouse_check_pressed()&&errorPop==false){
            selected.x=mx;
            selected.y=my;
            selected.w=gs;
            selected.h=gs;
            selected.cellX=round((mx - (this.x+4))/((this.sprite.width*this.scale)/((this.sprite.width*this.scale)/(this.gridSize*this.scale))))+(this.sorX/this.gridSize)
            selected.cellY=round((my - (this.y+4))/((this.sprite.height*this.scale)/((this.sprite.height*this.scale)/(this.gridSize*this.scale))))+(this.sorY/this.gridSize)
            selected.tId = floor((selected.cellY*this.columns)+selected.cellX)
            document.title = selected.tId;
            cur_value = this.sprite;
          }
        }
        
        let tId = ((selected.cellY*this.columns)+selected.cellX)
      }else{
        draw_set_color(0,0,0);
        draw_centered_text(this.x+(this.w/2), this.y+(this.h/2), "NO TILESET LOADED", this.w/20)
        buttons[0].hilite=true
        
        
      }
    }else{ // changes code editor text size?
      if(inside(mouse_x, mouse_y, this.x, this.y, this.w, this.h, 0, 0, 0)){
        if(document.getElementById("customTextBox")==null){
          
          //document.getElementById('codeIDE').style.fontSize = project.codeSize+'px';
        }
        wheelDir=0;
      }
    }
  }
}
project.gridSize=tilesRect.gridSize

selected = {
  x:null,
  y:null,
  w:null,
  h:null,
  tId:-1,
  cellX:null,
  cellY:null,
  draw:function(){
    if(menuRect.mode==0){
      draw_set_linewidth(1.5)
      draw_set_color(255,255,255)
      draw_set_linedash([])
      draw_rectangle(this.x, this.y, this.w, this.h,true)
      draw_set_linedash([])
    }
  }
}
code = {
  x:tilesRect.x+4,
  y:tilesRect.y+4,
  w:tilesRect.w
  
  
}

function text_fit(text,width){
  for(let i = 6; i<120; i++){// statilesRect.spritert way small
    ctx.font = i+'px Arial'; // set font for testing
    if(ctx.measureText(text).width>=width){ // checks if text doesnt fit bounds
      return i-1; // outputs previous i since it probably fit
    }
  }
}

function makeButton(x,y,label,funct){
  temp = {
    x:x,
    y:y,
    w:100,
    h:menuRect.h-8,
    tsize:2,
    bckCol:[188,188,188],
    brdCol:[55,55,55],
    lblCol:[55,55,55],
    hilite:false,
    label:label,
    draw:function(){
      draw_rect_ol(this.x,this.y,this.w,this.h,4,this.bckCol,this.brdCol)
      draw_set_color(this.lblCol[0],this.lblCol[1],this.lblCol[2]);
      draw_centered_text(this.x+this.w/2, this.y+this.h/2, this.label, this.tsize)
      if(this.hilite==true){
        draw_set_color(0,255,0);
        draw_set_linedash([])
        draw_set_linewidth(6)
        draw_rectangle(this.x, this.y, this.w, this.h,true)
      }
    },
    loop:function(){
      this.x = menuRect.x+x;
      this.y = menuRect.y+y;
      this.w = 80;
    if(this.label=='NAME'||this.label=='tId'||this.label=='START'||this.label=='LOOP'||this.label=='DRAW'||this.label=='HELP'||this.label=='LOAD'||this.label=='SAVE'){this.w = 60}
      this.h = menuRect.h-8;
      // hover and click
      if(inside(mouse_x, mouse_y, this.x, this.y, this.w, this.h, 0, 0, 0)){// hover
        this.bckCol=[222,222,222];
      if(this.label=='Tiles1'){t1HL=true}
      if(this.label=='Tiles2'){t2HL=true}
      if(this.label=='Objects'){oHL=true}
      if(this.label=='Tiles3'){t3HL=true}
        if(mouse_check_pressed()){
          eval(funct)
        }
      }else{
        this.bckCol=[188,188,188];
      if(this.label=='Tiles1'){t1HL=false}
      if(this.label=='Tiles2'){t2HL=false}
      if(this.label=='Objects'){oHL=false}
      if(this.label=='Tiles3'){t3HL=false}
      }
    }
  }
  buttons.push(temp)
}

let bX = 0
makeButton(4+bX,4,'load tSet','loadTiles();mouse_down=false');
bX+=80;
makeButton(4+bX,4,'tilegrid size','tilesRect.gridSize=parseInt(prompt("enter tile size",tilesRect.gridSize));tilesRect.columns = tilesRect.sprite.width/tilesRect.gridSize;project.tColumns = tilesRect.columns;project.gridSize=tilesRect.gridSize;localStorage.setItem("level_ed", JSON.stringify(project));mouse_down=false');
bX+=80;
makeButton(4+bX,4,'mapW','mapRect.mapW=parseInt(prompt("enter map width in cells",mapRect.mapW));mapRect.init();mouse_down=false');
bX+=80;
makeButton(4+bX,4,'mapH','mapRect.mapH=parseInt(prompt("enter map height in cells",mapRect.mapH));mapRect.init();mouse_down=false');
bX+=80;
makeButton(4+bX,4,'Save Project','saveProject();mouse_down=false');
bX+=80;
makeButton(4+bX,4,'Load Project','load();mouse_down=false');
bX+=80;
makeButton(4+bX,4,'Tiles1','mode=0;mouse_down=false');
bX+=80;
makeButton(4+bX,4,'Tiles2','mode=1;mouse_down=false');
bX+=80;
makeButton(4+bX,4,'Objects','mode=2;mouse_down=false');
bX+=80;
makeButton(4+bX,4,'Tiles3','mode=3;mouse_down=false');
bX+=80;
makeButton(4+bX,4,'Snap2Grid','if(snapped==true){snapped=false;buttons[10].label="FreeMove"}else{snapped=true;buttons[10].label="Snap2Grid"};mouse_down=false');
bX+=80;
makeButton(4+bX,4,'exportGAME','exportGAME();mouse_down=false');
bX+=80;
makeButton(4+bX,4,'test','test();mouse_down=false');
bX+=80;
function start(){
  
  if(localStorage.getItem("level_ed")!=null){
    project=JSON.parse(localStorage.getItem("level_ed"))
    if(project.tileSet!=null){
      tilesRect.sprite = draw_set_image(project.tileSet)
      tiles = project.tiles;
      tiles2 = project.tiles2;
      tiles3 = project.tiles3
      objects = project.objects;
      mapRect.mapW =  project.mapW;
      mapRect.mapH = project.mapH;
      mapRect.mapG = project.gridSize;
      tilesRect.gridSize = project.gridSize
      tilesRect.columns = project.tColumns;
      title = project.title;
    }
  }
}
function drawRoundedRectangle(x, y, width, height, radius) {
  if (radius > Math.min(width, height) / 2) {
    radius = Math.min(width, height) / 2;
  }
  
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.arcTo(x + width, y, x + width, y + radius, radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
  ctx.lineTo(x + radius, y + height);
  ctx.arcTo(x, y + height, x, y + height - radius, radius);
  ctx.lineTo(x, y + radius);
  ctx.arcTo(x, y, x + radius, y, radius);
  ctx.closePath();
  ctx.fill();
  //ctx.stroke();
  
}
colR=0;
colG=0;
colB=0;
colorShow=false
function show_color(){
  let col = getPixelColor(canvas, mouse_x, mouse_y)
  colR=col[0];
  colG=col[1];
  colB=col[2];
  draw_set_color(255,255,255)
  drawRoundedRectangle(tilesRect.x-50, tilesRect.y, 100, 100, 12)
  draw_set_color(colR,colG,colB)
  drawRoundedRectangle(tilesRect.x-40, tilesRect.y+10, 80, 80, 12)
}

function loop(){ //;vk_all_keys=[]
  if(keyboard_check(vk_ctrl)&&keyboard_check(vk_shift)){
    buttons[12].label='reset'
    buttons[12].hilite=true
  }else{
    buttons[12].label='TEST'
    buttons[12].hilite=false
  }
if(keyboard_check_pressed(120)){key_down[120]=false;key_pressed[120]=false;test()} //f9
  if(mouse_check_pressed() && keyboard_check(vk_c)){
    if(colorShow==false){
      colorShow=true
    }else{
      colorShow=false
      key_down[vk_c] = false;
      mouse_down=false;
      alert([colR,colG,colB])
    }
  }

  mapRect.loop();
  menuRect.loop();
  tilesRect.loop();
  if(mouse_x<canvas.width/2){
    document.title = title
  }
  
  if(keyboard_check(115)){
    resizePanels(mouse_x)
    
    //key_down[115] = false
  }
  
  //triggers when there is an error in the test game
  if(localStorage.getItem("level_ed_error")!=null){
    let err = JSON.parse(localStorage.getItem("level_ed_error"))
    showCenteredPopup(err.error)
    document.getElementById("erPop").focus();
    if(err.object!=null){
      for(let i = objects.length-1; i>=0; i--){
        objects[i].sel=false;
        if(err.object==i){
          objects[i].sel=true;
        }
      }
    }
    scriptMode=err.scriptMode
    
  if(scriptMode==0){object_code=JSON.stringify(objects[err.object].startCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
  if(scriptMode==1){object_code=JSON.stringify(objects[err.object].loopCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
  if(scriptMode==2){object_code=JSON.stringify(objects[err.object].drawCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
  if(scriptMode==5){object_code=JSON.stringify(project.gameCode).replace(/^"|"$/g, '').replace(/\\n/g, '\n');}
    document.getElementById("editor").style.display='block'
    editor.setValue(object_code);
   localStorage.removeItem("level_ed_error"); 
    menuRect.mode=1;
  }
  
}

function draw(){
  
  mapRect.draw();
  menuRect.draw();
  tilesRect.draw();
  selected.draw();
if(colorShow==true){show_color()}
}

function input(){
  
}
function draw_selcted(x,y,w,h){
  draw_set_linewidth(1)
  draw_set_color(0,255,0)
  draw_set_linedash([4,4])
  draw_rectangle(x, y, w, h,true)
  draw_set_linedash([])
}
function cursor(x,y,w,h,img){//selected.cellX,selected.cellY,tilesRect.sprite,tilesRect.gridSize
  if(img!=null){
    
    draw_image(img,x,y,w,h,0,0,0,tilesRect.gridSize*selected.cellX, tilesRect.gridSize*selected.cellY,tilesRect.gridSize,tilesRect.gridSize)
  }
  draw_set_linewidth(1)
  draw_set_color(255,255,255)
  draw_set_linedash([4,4])
  draw_rectangle(x, y, w, h,true)
  draw_set_linedash([])
}

function drawG(x,y,xw,yh,w,h){
  draw_set_linewidth(1)
  draw_set_alpha(1)
  draw_set_color(0,0,255)
  draw_set_linedash([4,4])
  for(let i = y; i <= y+h; i += yh){
    draw_line(x, i, x+w, i)
  }
  for(let i = x; i <= x+w; i += xw){
    draw_line(i, y, i, y+h)
  }
  draw_set_linedash([1])
  draw_set_alpha(1)
}
function draw_rect_ol(x,y,w,h,borThk,bakCol,borCol){
  draw_set_color(borCol[0],borCol[1],borCol[2])
  draw_rectangle(x,y,w,h,false,0,0,0)
  draw_set_color(bakCol[0],bakCol[1],bakCol[2])
  draw_rectangle(x+borThk,y+borThk,w-borThk*2,h-borThk*2,false,0,0,0)
}
function loadTiles(){
  var fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'image/*';
  fileInput.multiple = true; // Enable selection of multiple files
  fileInput.addEventListener('change', function(event) {
    var files = event.target.files
    if (files[0]) {
      for(let i = 0; i < files.length; i++){
        var reader = new FileReader();
        reader.onload = function(readerEvent) {
          var fileData =  readerEvent.target.result
          tilesRect.sprite = draw_set_image(fileData)
          project.tileSet=tilesRect.sprite.src;
          tilesRect.columns = tilesRect.sprite.width/tilesRect.gridSize;
          buttons[0].hilite=false
          localStorage.setItem("level_ed", JSON.stringify(project))
        };
        reader.readAsDataURL(files[i]);
      }
    }
  });
  fileInput.click();
}

function saveProject() {
  localStorage.setItem("level_ed", JSON.stringify(project))
  var content = JSON.stringify(project)
const blob = new Blob([content], { type: "text/json" }); // Create a Blob object with the JS content
  const url = URL.createObjectURL(blob); // Create a URL for the Blob
  const link = document.createElement("a");
  link.href = url;
  link.download = title; // Set the filename
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
function exportGAME() {
  var content = `<!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${title}</title>
  <style>
  body{
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: black;
    
  }
  canvas {
    // border: 2px solid #000;
    background-color: white;
    height:100vh;
  }
  </style>
  </head>
  
  <body>
  <canvas id="canvas"></canvas>
  
  <script>
  function resizeCanvas() {
    
    var WIDTH = window.visualViewport ? window.visualViewport.width : window.innerWidth;
    var HEIGHT = window.visualViewport ? window.visualViewport.height : window.innerHeight;
    canvas.style.width=WIDTH+'px';
    canvas.style.height=HEIGHT+'px';
    requestFullscreen(element)
  }
  //window.addEventListener('resize', resizeCanvas);
//setTimeout(function(){resizeCanvas()},100);
  
  `
  content += 'map = '+JSON.stringify(project)
  content += post_game
const blob = new Blob([content], { type: "text/html" }); // Create a Blob object with the JS content
  const url = URL.createObjectURL(blob); // Create a URL for the Blob
  const link = document.createElement("a");
  link.href = url;
  link.download = title.split('.')[0]+".html"; // Set the filename
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
function exportScript() {
  // GETS CODEIDE CURRENT TEXT
  var content = editor.getValue()
const blob = new Blob([content], { type: "text/javascript" }); // Create a Blob object with the JS content
  const url = URL.createObjectURL(blob); // Create a URL for the Blob
  const link = document.createElement("a");
  link.href = url;
  link.download = "map.js"; // Set the filename
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
function exportObject(ob) {
  // GETS CODEIDE CURRENT TEXT
  var content = JSON.stringify(ob)
const blob = new Blob([content], { type: "text/json" }); // Create a Blob object with the JS content
  const url = URL.createObjectURL(blob); // Create a URL for the Blob
  const link = document.createElement("a");
  link.href = url;
  link.download = "object.json"; // Set the filename
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
function loadScript(){
  document.getElementById('scriptInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
      const fileContent = e.target.result;
      //SETS CURRENT CODEIDE TEXT FROM LOCALFILE
      editor.setValue(fileContent);
      for(let i = 0; i < objects.length; i++){
        if(objects[i].sel==true){
        if(scriptMode==0){objects[i].startCode=fileContent}
        if(scriptMode==1){objects[i].loopCode=fileContent}
        if(scriptMode==2){objects[i].drawCode=fileContent}
        }
      }
    };
    reader.readAsText(file);  // Read the file content as text
    
  });
  document.getElementById('scriptInput').click();
}
function load(){
  document.getElementById('fileInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file && file.type === 'application/json') {
      const reader = new FileReader();
      reader.onload = function(e) {
        const fileContent = e.target.result;
        project = JSON.parse(fileContent);  // Display as string
        tilesRect.sprite = draw_set_image(project.tileSet)
        tilesRect.gridSize=project.gridSize
        tiles = project.tiles;
        tiles2 = project.tiles2;
        objects = project.objects;
        mapRect.mapW =  project.mapW;
        mapRect.mapH = project.mapH;
        document.title = file.name
        title = file.name
        project.title = title
        buttons[0].hilite=false
      };
      reader.readAsText(file);  // Read the file content as text
    } else {
      alert('Please select a valid JSON file');
    }
  });
  document.getElementById('fileInput').click();
}
function loadOb(){
  document.getElementById('fileInput').addEventListener('change', function(event) {
    const file = event.target.files[0];
    if (file && file.type === 'application/json') {
      const reader = new FileReader();
      reader.onload = function(e) {
        const fileContent = e.target.result;
        impOb = JSON.parse(fileContent);
        objects[hostOb].startCode=impOb.startCode
        objects[hostOb].loopCode=impOb.loopCode
        objects[hostOb].drawCode=impOb.drawCode
        objects[hostOb].w=impOb.w
        objects[hostOb].h=impOb.h
        objects[hostOb].rot=impOb.rot
      };
      reader.readAsText(file);  // Read the file content as text
    } else {
      alert('Please select a valid JSON file');
    }
  });
  document.getElementById('fileInput').click();
}
function show_code(){
  for(let i = objects.length-1; i>=0; i--){
    if(objects[i].sel==true){
    if(scriptMode==0){object_code=JSON.stringify(objects[i].startCode)}
    if(scriptMode==1){object_code=JSON.stringify(objects[i].loopCode)}
    if(scriptMode==2){object_code=JSON.stringify(objects[i].drawCode)}
    if(scriptMode==3){object_code=JSON.stringify(objects[i].name)}
    if(scriptMode==4){object_code=JSON.stringify(objects[i].tId)}
    if(scriptMode==5){object_code=JSON.stringify(project.gameCode)}
      //SETS CODEIDE CODE
      let code = object_code.replace(/^"|"$/g, '').replace(/\\n/g, '\n')
      document.getElementById("editor").style.display='block'
      editor.setValue(formatCode(code));
      
    }
  }
}

function test(){
  
  if(keyboard_check(vk_ctrl)&&keyboard_check(vk_shift)){
    if(confirm('Reset level_ed?')){
      localStorage.removeItem("level_ed");
      reset();
      location.reload();
    }
  }else{
    var content = pre_game
    content += 'map = '+JSON.stringify(project)
    content += TRYpost_game
    var myWindow = window.open();
    myWindow.document.write(content);
    myWindow.document.title = title;
  }
}
function helpBoxBAK() {
  //helptext
  if(document.getElementById("customTextBox")!=null){
    const element = document.getElementById("customTextBox");
    element.remove();
    return;
  }
  // Create a div element for the textbox
  var textBox = document.createElement('div');
  textBox.id = 'customTextBox';
  
  // Set styles for the textbox
  textBox.style.position = 'fixed';
  textBox.style.top = (tilesRect.y+4)+'px';
  textBox.style.left = (tilesRect.x+4)+'px';
  textBox.style.width = '50%';
  textBox.style.height = '50%';
  textBox.style.padding = '20px';
  textBox.style.backgroundColor = '#fff';
  textBox.style.border = '1px solid #ccc';
  textBox.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
  textBox.style.zIndex = '9999';
  //textBox.innerText = helpText;
  textBox.style.overflow = 'auto';
  // Append the textbox to the body
  document.body.appendChild(textBox);
  for (let i = 0; i < helpText.length; i++) {
    const button = document.createElement('button');
  button.textContent = `${helpText[i]}`;
  button.id = `${helpText[i]}`;
    button.style.fontSize = codeSize +'px';
    textBox.appendChild(button);
    textBox.appendChild(document.createElement('br'))
    // Add a click event listener to each button
    button.addEventListener('click', function () {
      //alert(this.id)
      cMcursor = editor.getCursor();
    editor.replaceRange(this.id, { line: cMcursor.line, ch: cMcursor.ch });
      navigator.clipboard.writeText(this.id);
      const element = document.getElementById("customTextBox");
      element.remove();
      editor.getInputField().focus();
      // navigator.clipboard.readText();
    });
  }
}

function helpBox() {
  //helptext
  if(document.getElementById("customTextBox")!=null){
    const element = document.getElementById("customTextBox");
    element.remove();
    return;
  }
  // Create a div element for the textbox
  var textBox = document.createElement('div');
  textBox.id = 'customTextBox';
  
  // Set styles for the textbox
  textBox.style.position = 'fixed';
  textBox.style.top = (tilesRect.y+4)+'px';
  textBox.style.left = (tilesRect.x+4)+'px';
  //textBox.style.transform = 'translate(+50%, 0%)';
  textBox.style.width = '50%';
  textBox.style.height = '50%';
  textBox.style.padding = '20px';
  textBox.style.backgroundColor = 'rgb(88,88,88)';
  textBox.style.border = '1px solid rgb(255,255,255)';
  textBox.style.boxShadow = '0 4px 8px rgba(255,255,255, 0.1)';
  textBox.style.zIndex = '9999';
  //textBox.innerText = helpText;
  textBox.style.overflow = 'auto';
  // Append the textbox to the body
  document.body.appendChild(textBox);
  for (let i = 0; i < helpText.length; i++) {
    const button = document.createElement('button');
  button.textContent = `${helpText[i]}`;
  button.id = `${helpText[i]}`;
    button.style.fontSize = project.codeSize +'px';
    button.style.backgroundColor = 'rgb(88,88,88)';
    button.style.color = 'rgb(255,255,255)';
    textBox.appendChild(button);
    textBox.appendChild(document.createElement('br'))
    // Add a click event listener to each button
    button.addEventListener('click', function () {
      cMcursor = editor.getCursor();
    editor.replaceRange(this.id, { line: cMcursor.line, ch: cMcursor.ch });
      navigator.clipboard.writeText(this.id);
      const element = document.getElementById("customTextBox");
      element.remove();
      editor.getInputField().focus();
      // navigator.clipboard.readText();
    });
  }
}
function makeName(){
  var name=null
  for(let index=0; index<100000; index++){
    var match= false;
    for(let i = 0; i < objects.length; i ++){
      if(objects[i].name=='object'+index){
        match = true
      }
    }
    if(match!=true){
      name= 'object'+index
      index = 100000;
    }
  }
  return name
}

function getPixelColor(canvas, x, y) {
  if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
    throw new Error("Invalid canvas element.");
  }
  
  const context = canvas.getContext("2d");
  if (!context) {
    throw new Error("Unable to get 2D context from canvas.");
  }
  
  // Ensure coordinates are within canvas bounds
  if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
    throw new Error("Coordinates are out of canvas bounds.");
  }
  
  // Get the pixel data at the specified coordinates
  const pixelData = context.getImageData(x, y, 1, 1).data;
  
  // Return the [r, g, b] values
  return [pixelData[0], pixelData[1], pixelData[2]];
}

function formatCode(inputCode) {
  // Split the code into lines
  var lines = inputCode.split('\n');
  // Define the number of spaces for one level of indentation
  const spaces = 2;
  // Initialize an indentation level trimmedLine.includes('{')  .join('\n') spaces = ' '.repeat(numberOfSpaces);
    let Indent = 0;
    let pre = ''
  for(let i = 0 ; i < lines.length; i++){lines[i] = lines[i].trim()}
    
    for(let i = 0 ; i < lines.length; i++){
      if(i>0){
      if(lines[i-1].includes('{')){Indent+=spaces}
      if(lines[i].includes('}')){Indent-=spaces}
        
      }
    if(Indent>0){pre = ' '.repeat(Indent)}else{pre = ''}
      lines[i] = pre+lines[i];
    }
    return lines.join('\n')
  }
  function resizePanels(xVal){
  if(xVal>canvas.width/2+4){xVal=canvas.width/2+4}
    tilesRect.x = xVal
    tilesRect.w = canvas.width-xVal
    document.getElementById("editor").style.left=(tilesRect.x+4)+'px';
    document.getElementById("editor").style.top=(tilesRect.y+4)+'px';
    document.getElementById("editor").style.width=(tilesRect.w-8)+'px';
    document.getElementById("editor").style.height=(tilesRect.h-8)+'px';
    document.getElementsByClassName("CodeMirror")[0].style.fontSize =   project.codeSize+"px";
    editor.refresh();
    
  }
  
  function showCenteredPopup(text) {
    errorPop=true;
    var div = document.createElement('div');
    div.id="erPop";
    div.style.position = 'fixed';
    div.style.top = '50vh';
    div.style.left = '50vw';
    div.style.transform = 'translate(-50%, -50%)';
    div.style.width = '400px';
    div.style.height = '200px';
    div.style.background = 'white';
    div.style.color = 'black';
    div.style.padding = '20px';
    div.style.borderRadius = '10px';
    div.style.boxShadow = '0 0 10px 0px black';
    div.style.textAlign = 'center';
    div.style.zIndex = '9999';
    div.style.display = 'block';
    div.style.fontSize = '18px';
    
    var h1 = document.createElement('h1');
    h1.style.margin = '0';
    h1.style.padding = '0 0 10px 0';
    h1.style.fontSize = '18px';
    h1.innerHTML = text;
    
    var button = document.createElement('button');
    button.style.background = '#00b3cc';
    button.style.border = 'none';
    button.style.borderRadius = '5px';
    button.style.padding = '10px 20px';
    button.style.margin = '10px auto';
    button.style.cursor = 'pointer';
    button.addEventListener('click', function() {
      errorPop=false;
      mouse_down=false;
      div.parentNode.removeChild(div);
    });
    
    button.textContent = 'OK';
    
    div.appendChild(h1);
    div.appendChild(button);
    document.body.appendChild(div);
  }
document.getElementById('editor').addEventListener('contextmenu', function(event) {
  // Only allow context menu for this element
  event.stopPropagation();
});
  </script>
  <script type='text/javascript' src='engine.js'></script>
  
  </body>
  </html>
  
  
