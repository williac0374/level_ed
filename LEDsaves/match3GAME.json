{"title":"match3GAME.json","tileSet":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAAAgCAYAAABEmHeFAAAAAXNSR0IArs4c6QAAAbRJREFUeF7t3C9uAkEUx3E2VFSiqhpUKxGQJhyAA2A4AqI3qGyqe4VegIRDYEnIIpBUERSqEkPa7CTTbLZA+bPz3szsd9Su2d/M7PvkuZeMO53vWoVXf3Kjevrn0VQ1/2OoGl976b2rbiABAAA0K9A7AIM0TSQupAiv9diWiP3NWCzn5tl2gPXrl2j+/VvD5NkOsF2sRPNvW02TZzvA7HMnmv/0UDd5FsB0txHN79bvTN7eDiCBAAAA8ApAVvT5onSNAAAA8A5AtiEpBAAAgJcApBAAAADeApBAAAAAeA3ANQIAAMB7AC4RAAAAQQBwhQAAAAgGgAsEAABAUADKRgAAAAQHoEwEAABAkADKQgAAAAQLoAwEAABA0ACuRQAAAAQP4BoEAABAFAAuRQAAAEQD4BIEAABAVADORQAAAEQH4BwEAABAlABORQAAAEQL4BQEAABA1AD+QwAAAEQP4BgCAACgEgAOIQAAACoDYB8CAACgUgCKCLL3/GIyHJPhijXh8v3PZDjXg7DsYQ7NIgUAAFwWfPHbR0cjSm5EO4vp0Lp/wLvhuLrXIZ8OAPk7zydqA/gB9vRcblcJJGMAAAAASUVORK5CYII=","objects":[{"name":"object0","tId":0,"depth":0,"x":253,"y":107,"mapX":1.5,"mapY":0.5,"w":1,"h":1,"rot":0,"ox":0,"oy":0,"startCode":"working=false\nfrom = {x:-1,y:-1}\n\nsetInterval(function(){\n  tileHandler();\n  \n},150)","loopCode":"if(mouse_check_pressed()){\n  tileClick()\n}","drawCode":"","sel":false}],"gameCode":"\nfunction tileHandler(){\n  // starts at the bottom of the map\n  // checks from left to right\n  for (let y = mapH-1; y >=0; y--) {\n    for (let x = 0; x < mapW; x++) {\n      //gets tiles[y][x]\n      let curr = tiles[y][x]\n      let above = null\n      // gets tile  directly above if possible\n      if(y>0){\n        above = tiles[y-1][x]\n      }\n      if(curr==-1&&above!=null&&above!=-1){\n        // changes current tile to the value\n        // of the tile above it and clears the\n        // above tile.\n        tiles[y][x]=above;\n        tiles[y-1][x]=-1\n      }\n    }\n  }\n  //when all that is done the top row will be blank so\n  // now we fill it\n  for (let x = 0; x < mapW; x++) {\n    if(tiles[0][x]==-1){\n      tiles[0][x]=choose(1,2,3,4,5)\n    }\n  }\n  \n  // checks for any empty tiles\n  // to set the working var to keep players\n  // from being able to click tils when\n  // the gameboard is still updating\n  let empty=false\n  for (let y = mapH-1; y >=0; y--) {\n    for (let x = 0; x < mapW; x++) {\n    if(tiles[y][x]==-1){empty=true}\n    }\n  }\n  working=empty\n  if(working==false){\n    if(game_over()){\n      alert('no more  moves')\n    }\n    tile_scorer()\n  }\n}\nfunction tile_scorer() {\n  let rows = tiles.length;\n  let cols = tiles[0].length;\n  let matches = [];\n  \n  // Check horizontal matches\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols - 2; c++) {\n      let tile = tiles[r][c];\n      if (tile !== -1 && tile === tiles[r][c + 1] && tile === tiles[r][c + 2]) {\n        matches.push([r, c], [r, c + 1], [r, c + 2]);\n        let cOffset = c + 3;\n        while (cOffset < cols && tiles[r][cOffset] === tile) {\n          matches.push([r, cOffset]);\n          cOffset++;\n        }\n      }\n    }\n  }\n  \n  // Check vertical matches\n  for (let c = 0; c < cols; c++) {\n    for (let r = 0; r < rows - 2; r++) {\n      let tile = tiles[r][c];\n      if (tile !== -1 && tile === tiles[r + 1][c] && tile === tiles[r + 2][c]) {\n        matches.push([r, c], [r + 1, c], [r + 2, c]);\n        let rOffset = r + 3;\n        while (rOffset < rows && tiles[rOffset][c] === tile) {\n          matches.push([rOffset, c]);\n          rOffset++;\n        }\n      }\n    }\n  }\n  \n  // Mark matched tiles as -1\n  matches.forEach(([r, c]) => {\n    tiles[r][c] = -1;\n  });\n}\n\nfunction game_over() {\n  let rows = tiles.length;\n  let cols = tiles[0].length;\n  \n  // Helper function to swap two tiles\n  function swap(r1, c1, r2, c2) {\n    let temp = tiles[r1][c1];\n    tiles[r1][c1] = tiles[r2][c2];\n    tiles[r2][c2] = temp;\n  }\n  \n  // Helper function to check for a match after a swap\n  function has_match() {\n    // Check horizontal matches\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < cols - 2; c++) {\n        let tile = tiles[r][c];\n        if (tile !== -1 && tile === tiles[r][c + 1] && tile === tiles[r][c + 2]) {\n          return true;\n        }\n      }\n    }\n    \n    // Check vertical matches\n    for (let c = 0; c < cols; c++) {\n      for (let r = 0; r < rows - 2; r++) {\n        let tile = tiles[r][c];\n        if (tile !== -1 && tile === tiles[r + 1][c] && tile === tiles[r + 2][c]) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n  \n  // Try swapping each tile with its adjacent tiles\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (c < cols - 1) { // Swap right\n        swap(r, c, r, c + 1);\n        if (has_match()) {\n          swap(r, c, r, c + 1); // Swap back\n          return false;\n        }\n        swap(r, c, r, c + 1); // Swap back\n      }\n      if (r < rows - 1) { // Swap down\n        swap(r, c, r + 1, c);\n        if (has_match()) {\n          swap(r, c, r + 1, c); // Swap back\n          return false;\n        }\n        swap(r, c, r + 1, c); // Swap back\n      }\n    }\n  }\n  \n  // No possible moves left\n  return true;\n}\n\n\nfunction tileClick(){\nif(working){return}\n  // keeps from rapid clicking tiles before the game board is ready\n  working=true;\n  mx = floor(mouse_x/gridSize)//*gridSize\n  my = floor(mouse_y/gridSize)//*gridSize\n  if(from.x==-1){\n    from.x=mx;\n    from.y=my;\n  }else{\n    let f = tiles[from.y][from.x]\n    let t = tiles[my][mx]\n    tiles[my][mx] = f\n    tiles[from.y][from.x] = t\n    from.x=-1\n    \n  }\n  /*\n  \nto = {x:-1,y:-1}\nfrom = {x:-1,y:-1}\n  */\n  // set_tile(tiles,mx,my,-1)\n}","codeSize":17,"tColumns":6,"view":{"x":0,"y":0,"w":288,"h":576},"tiles":[[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1]],"tiles2":[[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1]],"tiles3":[[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1,-1,-1,-1]],"mapW":9,"mapH":18,"gridSize":32}